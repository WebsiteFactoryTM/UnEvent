# Redis Usage Analysis - Complete Overview

This document provides a comprehensive analysis of where and how Redis commands are generated across the entire project (backend, worker, frontend).

## Table of Contents

1. [Redis Client Implementations](#redis-client-implementations)
2. [Redis Command Generation Locations](#redis-command-generation-locations)
3. [Command Breakdown by Type](#command-breakdown-by-type)
4. [Key Patterns Used](#key-patterns-used)
5. [Frequency and Volume Estimates](#frequency-and-volume-estimates)
6. [Code References](#code-references)

---

## Redis Client Implementations

### 1. Backend - Upstash REST API Client

**Location**: `apps/backend/src/utils/redis.ts`

**Client Library**: `@upstash/redis` (REST API)

**Connection Type**: Stateless REST API calls (no persistent connection)

**Environment Variables**:
- `PAYLOAD_PRIVATE_UPSTASH_REDIS_REST_URL`
- `PAYLOAD_PRIVATE_UPSTASH_REDIS_REST_TOKEN`

**Wrapper Methods Available** (lines 10-74):
```typescript
- get(key: string): Promise<string | null>
- set(key: string, value: string, ...args: unknown[]): Promise<string | null>
- incr(key: string): Promise<number>
- del(...keys: string[]): Promise<number>
- expire(key: string, seconds: number): Promise<number>
- scan(cursor: string | number, ...args: unknown[]): Promise<[string, string[]]>
- mget(...keys: string[]): Promise<(string | null)[]>
- eval(script: string, keys: string[], args: (string | number)[]): Promise<unknown>
```

**Usage**: Feed counters, metrics deduplication, caching

**Optimizations**:
- `mget()` batches multiple GET operations (line 67-69)
- `eval()` supports Lua scripts for atomic operations (line 71-73)
- `set()` with NX flag for atomic check-and-set (line 20-30)

---

### 2. Worker - ioredis Native Client

**Location**: `apps/worker/src/redis.ts`

**Client Library**: `ioredis` (native Redis protocol)

**Connection Type**: Persistent TCP/TLS connection

**Environment Variables**:
- `UPSTASH_REDIS_URL` (preferred - TLS connection string)
- OR `REDIS_HOST`, `REDIS_PASSWORD`, `REDIS_PORT` (fallback)

**Connection Configuration** (lines 29-43):
```typescript
redisClient = new Redis({
  host,
  port,
  password,
  tls: isTLS ? { rejectUnauthorized: true } : undefined,
  maxRetriesPerRequest: null, // Required by BullMQ for blocking operations
  retryStrategy: (times: number) => Math.min(times * 50, 2000),
})
```

**Usage**: BullMQ queue operations (notifications, maintenance)

**Event Handlers** (lines 45-67):
- `error`: Logs connection errors
- `connect`: Logs successful connection
- `ready`: Logs when Redis is ready for commands
- `close`: Logs connection closure
- `reconnecting`: Logs reconnection attempts
- `end`: Logs connection end

---

### 3. Frontend - Upstash REST API Client

**Location**: `apps/frontend/lib/redis/index.tsx`

**Client Library**: `@upstash/redis` (REST API)

**Connection Type**: Stateless REST API calls

**Environment Variables**:
- `NEXT_PRIVATE_UPSTASH_REDIS_REST_URL`
- `NEXT_PRIVATE_UPSTASH_REDIS_REST_TOKEN`

**Wrapper Methods Available** (lines 6-27):
```typescript
- get(key: string): Promise<string | null>
- set(key: string, value: string, ...args: any[]): Promise<string | null>
```

**Usage**: Minimal - likely for client-side caching (limited implementation)

---

### 4. Backend Notifications Queue - ioredis Client

**Location**: `apps/backend/src/utils/notificationsQueue.ts`

**Client Library**: `ioredis` (separate instance from main backend Redis)

**Connection Type**: Persistent TCP/TLS connection (separate from worker)

**Environment Variables**: Same as worker (`UPSTASH_REDIS_URL` or `REDIS_HOST`/`REDIS_PASSWORD`/`REDIS_PORT`)

**Purpose**: Enqueuing email notification jobs for BullMQ worker

**Connection Logic** (lines 15-164):
- Creates separate Redis connection specifically for BullMQ queue operations
- Includes connection retry logic with max attempts (3)
- Tracks connection state (`isRedisAvailable`)

---

## Redis Command Generation Locations

### A. BullMQ Queue Operations (Worker)

#### 1. Queue Initialization

**Location**: `apps/worker/src/queues/index.ts`

**Queues Created**:
- `notificationsQueue` (lines 8-28)
- `maintenanceQueue` (lines 30-46)

**Rate Limiting** (configured in processors):
- `notificationsQueue`: 2 requests/second (lines 108-111 in `notifications.ts`)
- `maintenanceQueue`: 2 requests/second (lines 89-92 in `maintenance.ts`)

**Queue Configuration**:
```typescript
defaultJobOptions: {
  attempts: 3,
  backoff: { type: 'exponential', delay: 2000 },
  removeOnComplete: { age: 24 * 3600, count: 1000 },
  removeOnFail: { age: 7 * 24 * 3600 },
}
```

**Redis Commands Generated by BullMQ**:
- `BRPOP` / `BLPOP`: Blocking pop for job polling
- `LPUSH`: Adding jobs to queue
- `SET`: Job locking and state management
- `GET`: Reading job data
- `DEL`: Removing completed/failed jobs
- `ZADD`: Delayed jobs (sorted sets)
- `ZRANGE`: Retrieving delayed jobs
- `INCR`: Job ID generation
- `EXPIRE`: Key expiration for job locks

**Estimated Commands per Poll Cycle**: ~5-10 commands per worker per poll

---

#### 2. Worker Processors

**Location**: `apps/worker/src/processors/notifications.ts` (lines 17-162)

**Worker Configuration** (lines 101-111):
```typescript
{
  connection: getRedisConnection(),
  concurrency: settings.concurrency,        // 5 (prod), 2 (staging), 1 (dev)
  lockDuration: settings.lockDuration,     // 60s (prod), 120s (staging), 120s (dev)
  stalledInterval: settings.stalledInterval, // 60s (prod), 120s (staging), 60s (dev)
  maxStalledCount: settings.maxStalledCount, // 2
  limiter: {
    max: 2,        // 2 requests
    duration: 1000, // per 1000ms (1 second)
  },
}
```

**Polling Frequency**:
- **Production**: Every ~5-10 seconds when idle
- **Staging**: Every ~10-20 seconds when idle
- **Development**: Every ~20-30 seconds when idle

**Daily Command Volume**:
- **Production**: ~35,000-50,000 commands/day
- **Staging**: ~20,000-30,000 commands/day
- **Development**: ~10,000-15,000 commands/day

**Calculation**:
```
Production: 2 workers × 6 polls/min × 60 min × 24 hours × 8 commands/poll = ~34,560 commands/day
Plus job processing overhead: ~35,000-50,000 commands/day
```

**Location**: `apps/worker/src/processors/maintenance.ts` (lines 17-111)

**Worker Configuration**: Similar to notifications worker but with different concurrency (3 prod, 1 staging/dev)

---

### B. Feed Counters (Backend)

**Location**: `apps/backend/src/collections/Feed/counters.ts`

#### 1. Counter Increment Functions

**Lua Script** (lines 23-31):
```lua
local key = KEYS[1]
local expiration = tonumber(ARGV[1])
local current = redis.call('INCR', key)
if current == 1 then
  redis.call('EXPIRE', key, expiration)
end
return current
```

**Functions**:
- `bumpView()` (lines 48-57): `EVAL` script → 1 Redis command
- `bumpFavorite()` (lines 63-72): `EVAL` script → 1 Redis command
- `bumpBooking()` (lines 78-87): `EVAL` script → 1 Redis command
- `bumpImpression()` (lines 94-103): `EVAL` script → 1 Redis command

**Key Pattern**: `feed:counters:{kind}:{listingId}:{metric}:{date}`
- Example: `feed:counters:locations:123:views:2025-01-15`

**TTL**: 7 days (604,800 seconds)

**Command Generated**: `EVAL` (combines INCR + EXPIRE into single atomic operation)

**Frequency**: On-demand (triggered by user actions)

**Estimated Daily Volume**: Variable
- Low traffic: 100-500 commands/day
- Medium traffic: 1,000-5,000 commands/day
- High traffic: 10,000+ commands/day

---

#### 2. Counter Flush Function

**Location**: `apps/backend/src/collections/Feed/counters.ts` (lines 109-250)

**Function**: `flushCountersToDaily()`

**Redis Commands Generated**:

1. **SCAN** (lines 117-122):
```typescript
let cursor = '0'
do {
  const [nextCursor, batch] = await redis.scan(cursor, 'MATCH', pattern, 'COUNT', 100)
  cursor = nextCursor
  keys.push(...batch)
} while (cursor !== '0')
```
- Pattern: `feed:counters:*`
- Commands: ~1 SCAN per 100 keys (iterative)

2. **MGET** (line 129):
```typescript
const values = await redis.mget(...keys)
```
- Commands: 1 MGET command (batches all GET operations)
- Optimization: Reduces N GET commands to 1 MGET

3. **DEL** (lines 240-242):
```typescript
if (keys.length > 0) {
  await redis.del(...keys)
}
```
- Commands: 1 DEL command (batches all deletions)

**Total Commands per Flush**:
- With 100 keys: ~3 commands (1 SCAN + 1 MGET + 1 DEL)
- With 1,000 keys: ~13 commands (10 SCAN + 1 MGET + 1 DEL)
- With 10,000 keys: ~103 commands (100 SCAN + 1 MGET + 1 DEL)

**Frequency**: Daily at midnight UTC (1440 minute interval)

**Scheduled Location**: `apps/backend/src/schedulers/feed.ts` (lines 29-49)

**Daily Command Volume**:
- With 100 active counters: ~3 commands/day
- With 1,000 active counters: ~13 commands/day
- With 10,000 active counters: ~103 commands/day

---

### C. Metrics Endpoint (Backend)

**Location**: `apps/backend/src/endpoints/metrics/index.ts`

#### 1. View Deduplication

**Function**: `shouldRecordView()` (lines 44-86)

**Redis Command** (line 81):
```typescript
const wasSet = await redis.set(dedupeKey, '1', 'EX', ttlSeconds, 'NX')
```

**Command Generated**: `SET key value EX seconds NX`
- Atomic operation: Sets key only if it doesn't exist
- Sets expiration to end of day + 1 hour buffer
- Returns `null` if key exists (already recorded), `'OK'` if newly set

**Key Pattern**: `metrics:view:{kind}:{listingId}:{date}:{identifier}`
- Identifier priority: `user:{userId}` > `session:{sessionId}` > `ip:{ipHash}` > `anonymous`
- Example: `metrics:view:locations:123:2025-01-15:user:456`

**TTL Calculation** (lines 78-80):
```typescript
const now = new Date()
const endOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1)
const ttlSeconds = Math.floor((endOfDay.getTime() - now.getTime()) / 1000) + 3600
```

**Frequency**: On-demand (API calls from frontend)

**Estimated Daily Volume**: Variable
- Low traffic: 50-200 commands/day
- Medium traffic: 500-2,000 commands/day
- High traffic: 5,000+ commands/day

---

#### 2. Impression Recording

**Function**: `recordImpression()` (lines 161-212)

**Redis Command**: Calls `bumpImpression()` → `EVAL` script

**Frequency**: On-demand (API calls from frontend)

**Estimated Daily Volume**: Similar to view deduplication

---

### D. Feed Schedulers (Backend)

**Location**: `apps/backend/src/schedulers/feed.ts`

#### 1. Flush Counters Scheduler

**Function**: `flushCountersToDaily()` (scheduled, lines 29-49)

**Schedule**: Daily at midnight UTC (1440 minute interval)
- Configurable via `SCHEDULER_FEED_FLUSH_INTERVAL_MINUTES`

**Redis Commands**: See [Counter Flush Function](#2-counter-flush-function) above

---

#### 2. Aggregate Daily Scheduler

**Function**: `aggregateDaily()` (scheduled, lines 62-82)

**Location**: `apps/backend/src/collections/Feed/workers/aggregateDaily.ts`

**Schedule**: Every 120 minutes (2 hours)
- Configurable via `SCHEDULER_FEED_AGGREGATE_INTERVAL_MINUTES`

**Redis Commands**: **NONE** (Postgres-only operations)

---

#### 3. Rank Segments Scheduler

**Function**: `rankSegments()` (scheduled, lines 95-115)

**Location**: `apps/backend/src/collections/Feed/workers/rankSegments.ts`

**Schedule**: Every 120 minutes (2 hours)
- Configurable via `SCHEDULER_FEED_RANK_INTERVAL_MINUTES`

**Redis Commands**: **NONE** (Postgres-only operations)

---

### E. Notification Enqueuing (Backend)

**Location**: `apps/backend/src/utils/notificationsQueue.ts`

#### Enqueue Function

**Function**: `enqueueNotification()` (lines 288-346)

**Redis Commands Generated**: BullMQ `queue.add()` → `LPUSH` + `SET` + `ZADD` (if delayed)

**Command Breakdown**:
- `LPUSH`: Add job to queue
- `SET`: Store job data
- `ZADD`: If delay/priority specified, add to delayed jobs sorted set
- `INCR`: Generate job ID

**Estimated Commands per Enqueue**: ~2-4 commands

**Triggered From** (15 locations):

1. **User Hooks**:
   - `apps/backend/src/collections/Users/hooks/afterChange/newUserWelcomeEmail.ts` (line 164)
   - `apps/backend/src/collections/Users/hooks/afterChange/notifyAdminNewUser.ts` (line 18)
   - `apps/backend/src/collections/Users/hooks/sendWelcomeEmail.ts` (line 66)

2. **Listing Hooks**:
   - `apps/backend/src/collections/Listings/_hooks/afterChange/notifyListingCreated.ts` (line 53)
   - `apps/backend/src/collections/Listings/_hooks/afterChange/notifyAdminNewListing.ts` (line 130)
   - `apps/backend/src/collections/Listings/_hooks/afterChange/notifyListingModeration.ts` (lines 139, 163)

3. **Review Hooks**:
   - `apps/backend/src/collections/Reviews/hooks/afterChange/notifyListingOwnerNewReview.ts` (line 204)
   - `apps/backend/src/collections/Reviews/hooks/afterChange/notifyReviewModeration.ts` (lines 186, 204)
   - `apps/backend/src/collections/Reviews/hooks/afterChange/notifyAdminNewReview.ts` (line 119)

4. **Claim Hooks**:
   - `apps/backend/src/collections/Claims/hooks/afterChange/notifyClaimant.ts` (lines 63, 74)
   - `apps/backend/src/collections/Claims/hooks/afterChange/notifyAdminNewClaim.ts` (line 68)

5. **Endpoints**:
   - `apps/backend/src/endpoints/contactEndpoint.ts` (line 188)
   - `apps/backend/src/endpoints/reportEndpoint.ts` (line 153)

**Email Event Types** (lines 230-271):
- User-facing: `user.welcome`, `user.welcome.client`, `user.welcome.host`, `user.welcome.organizer`, `user.welcome.provider`, `user.reset.start`, `user.reset.confirmed`, `message.new`, `listing.approved`, `listing.rejected`, `listing.finished`, `listing.recommended`, `listing.search-stats`, `listing.view-stats`, `listing.claim.invitation`, `account.verified`, `account.verification-rejected`, `account.deleted`, `listing.favorited`, `review.new`, `review.approved`, `review.rejected`, `event.reminder.24h`, `event.participation.reminder`, `event.participation.confirmed`
- Admin: `admin.listing.pending`, `admin.review.pending`, `admin.user.new`, `admin.report.new`, `admin.password.changed`, `admin.verification.request`, `admin.digest.daily`, `admin.listing.report`, `admin.profile.report`, `admin.contact`, `admin.claim.pending`, `claim.approved`, `claim.rejected`

**Frequency**: On-demand (triggered by Payload hooks and endpoints)

**Estimated Daily Volume**: Variable
- Low traffic: 20-50 enqueues/day = ~40-200 commands/day
- Medium traffic: 100-500 enqueues/day = ~200-2,000 commands/day
- High traffic: 1,000+ enqueues/day = ~2,000+ commands/day

---

## Command Breakdown by Type

| Command Type | Location | Frequency | Estimated Daily Volume | Notes |
|--------------|----------|-----------|------------------------|-------|
| **BRPOP/BLPOP** | BullMQ workers | Every 5-60s (env-dependent) | ~17,280-34,560 | Blocking pop for job polling |
| **LPUSH** | Notification enqueue | On-demand | ~40-2,000 | Adding jobs to queue |
| **SET** | BullMQ, deduplication | Continuous | ~20,000-50,000 | Job locking, state, deduplication |
| **GET** | BullMQ | Continuous | ~5,000-15,000 | Reading job data |
| **DEL** | BullMQ, flush | Daily + on-demand | ~100-1,000 | Removing completed jobs, flushing counters |
| **ZADD** | BullMQ delayed jobs | On-demand | ~20-200 | Delayed/priority jobs |
| **ZRANGE** | BullMQ | Continuous | ~1,000-5,000 | Retrieving delayed jobs |
| **INCR** | BullMQ, counters | On-demand | ~100-5,000 | Job IDs, counter increments |
| **EXPIRE** | BullMQ, counters | On-demand | ~100-5,000 | Key expiration |
| **EVAL** | Counter increments | On-demand | ~100-10,000 | Lua script (INCR + EXPIRE) |
| **SCAN** | Counter flush | Daily | ~1-100 | Iterating counter keys |
| **MGET** | Counter flush | Daily | ~1 | Batch GET operations |
| **SET NX EX** | View deduplication | On-demand | ~50-5,000 | Atomic check-and-set |

---

## Key Patterns Used

### Feed Counters
- Pattern: `feed:counters:{kind}:{listingId}:{metric}:{date}`
- Examples:
  - `feed:counters:locations:123:views:2025-01-15`
  - `feed:counters:events:456:favorites:2025-01-15`
  - `feed:counters:services:789:bookings:2025-01-15`
  - `feed:counters:locations:123:impressions:2025-01-15`
- TTL: 7 days (604,800 seconds)

### Metrics Deduplication
- Pattern: `metrics:view:{kind}:{listingId}:{date}:{identifier}`
- Identifier formats:
  - `user:{userId}` (authenticated users)
  - `session:{sessionId}` (browser sessions)
  - `ip:{ipHash}` (IP address - last octet masked)
  - `anonymous` (fallback)
- Examples:
  - `metrics:view:locations:123:2025-01-15:user:456`
  - `metrics:view:events:789:2025-01-15:session:abc123`
  - `metrics:view:services:321:2025-01-15:ip:192.168.1.x`
- TTL: Until end of day + 1 hour buffer

### BullMQ Queue Keys
- Pattern: `bull:{queueName}:*`
- Examples:
  - `bull:notifications:*` (job data, locks, delays, etc.)
  - `bull:maintenance:*` (job data, locks, delays, etc.)
- Managed by BullMQ internally

---

## Frequency and Volume Estimates

### Production Environment (NODE_ENV=production)

| Component | Commands/Day | Notes |
|-----------|--------------|-------|
| BullMQ Worker Polling | ~35,000-50,000 | Primary source - continuous polling |
| Counter Increments | ~1,000-10,000 | Variable based on user activity |
| View Deduplication | ~500-5,000 | Variable based on page views |
| Counter Flush | ~3-103 | Depends on active counter keys |
| Notification Enqueue | ~200-2,000 | Depends on user actions |
| **Total** | **~37,000-67,000** | **Exceeds 10K free tier by 3.7-6.7x** |

### Staging Environment (NODE_ENV=staging)

| Component | Commands/Day | Notes |
|-----------|--------------|-------|
| BullMQ Worker Polling | ~20,000-30,000 | Reduced polling frequency |
| Counter Increments | ~500-5,000 | Lower traffic |
| View Deduplication | ~200-2,000 | Lower traffic |
| Counter Flush | ~3-103 | Same as production |
| Notification Enqueue | ~100-1,000 | Lower traffic |
| **Total** | **~20,800-38,100** | **Exceeds 10K free tier by 2-3.8x** |

### Development Environment (NODE_ENV=development)

| Component | Commands/Day | Notes |
|-----------|--------------|-------|
| BullMQ Worker Polling | ~10,000-15,000 | Minimal polling |
| Counter Increments | ~50-500 | Very low traffic |
| View Deduplication | ~20-200 | Very low traffic |
| Counter Flush | ~3-103 | Same as production |
| Notification Enqueue | ~20-200 | Very low traffic |
| **Total** | **~10,100-15,900** | **Near or slightly over 10K free tier** |

---

## Code References

### Worker Configuration Files

- **Worker Settings**: `apps/worker/src/config/workerSettings.ts`
  - Production: 5 concurrency (notifications), 3 concurrency (maintenance)
  - Staging: 2 concurrency (notifications), 1 concurrency (maintenance)
  - Development: 1 concurrency (both)

- **Notifications Processor**: `apps/worker/src/processors/notifications.ts`
  - Lines 101-111: Worker configuration with rate limiter
  - Lines 36: Calls `sendEmailFromRegistry()` (no Redis)

- **Maintenance Processor**: `apps/worker/src/processors/maintenance.ts`
  - Lines 83-92: Worker configuration with rate limiter
  - Lines 46: Calls `sendEmailFromRegistry()` (no Redis)

- **Queue Definitions**: `apps/worker/src/queues/index.ts`
  - Lines 8-28: Notifications queue
  - Lines 30-46: Maintenance queue

### Backend Redis Usage

- **Redis Client**: `apps/backend/src/utils/redis.ts`
  - Lines 10-74: Wrapper methods
  - Lines 79-98: Client initialization

- **Feed Counters**: `apps/backend/src/collections/Feed/counters.ts`
  - Lines 23-31: Lua script for atomic INCR + EXPIRE
  - Lines 37-41: `incrWithExpire()` function
  - Lines 48-57: `bumpView()` function
  - Lines 63-72: `bumpFavorite()` function
  - Lines 78-87: `bumpBooking()` function
  - Lines 94-103: `bumpImpression()` function
  - Lines 109-250: `flushCountersToDaily()` function

- **Metrics Endpoint**: `apps/backend/src/endpoints/metrics/index.ts`
  - Lines 44-86: `shouldRecordView()` deduplication function
  - Lines 88-159: `recordView()` handler
  - Lines 161-212: `recordImpression()` handler

- **Feed Schedulers**: `apps/backend/src/schedulers/feed.ts`
  - Lines 29-49: `flushCountersToDaily` scheduler
  - Lines 62-82: `aggregateDaily` scheduler
  - Lines 95-115: `rankSegments` scheduler

- **Notification Queue**: `apps/backend/src/utils/notificationsQueue.ts`
  - Lines 15-164: `getRedisForBullMQ()` connection function
  - Lines 171-224: `getNotificationsQueue()` queue creation
  - Lines 288-346: `enqueueNotification()` function

### Frontend Redis Usage

- **Redis Client**: `apps/frontend/lib/redis/index.tsx`
  - Lines 6-27: Minimal wrapper (get, set only)
  - Lines 32-51: Client initialization

---

## Optimizations Already Implemented

### 1. Lua Scripts for Atomic Operations
- **Location**: `apps/backend/src/collections/Feed/counters.ts` (lines 23-31)
- **Benefit**: Combines `INCR + EXPIRE` into single `EVAL` command
- **Savings**: 50% reduction (2 commands → 1 command)

### 2. Batch Operations (MGET)
- **Location**: `apps/backend/src/collections/Feed/counters.ts` (line 129)
- **Benefit**: Batches multiple GET operations into single MGET
- **Savings**: N commands → 1 command (e.g., 100 GETs → 1 MGET)

### 3. Atomic Check-and-Set (SET NX EX)
- **Location**: `apps/backend/src/endpoints/metrics/index.ts` (line 81)
- **Benefit**: Combines GET + SET into single atomic operation
- **Savings**: 50% reduction (2 commands → 1 command)

### 4. Environment-Aware Worker Settings
- **Location**: `apps/worker/src/config/workerSettings.ts`
- **Benefit**: Reduces polling frequency in dev/staging
- **Savings**: 50-70% reduction in worker polling commands

### 5. Rate Limiting
- **Location**: `apps/worker/src/processors/notifications.ts` (lines 108-111)
- **Location**: `apps/worker/src/processors/maintenance.ts` (lines 89-92)
- **Benefit**: Prevents Resend API rate limit errors
- **Side Effect**: Also reduces Redis command burst rate

---

## Potential Command Generation Hotspots

### 1. BullMQ Workers (Highest Impact)
- **Current**: ~35,000-50,000 commands/day (production)
- **Reason**: Continuous polling every 5-10 seconds
- **Mitigation**: Already optimized with environment-aware settings
- **Further Optimization**: Consider increasing `stalledInterval` in production if acceptable

### 2. Counter Increments
- **Current**: ~1,000-10,000 commands/day (variable)
- **Reason**: Every user action (view, favorite, booking, impression)
- **Mitigation**: Already optimized with Lua scripts
- **Further Optimization**: Consider batching increments or reducing flush frequency

### 3. View Deduplication
- **Current**: ~500-5,000 commands/day (variable)
- **Reason**: Every unique page view per user/session/IP
- **Mitigation**: Already optimized with atomic SET NX EX
- **Further Optimization**: Consider longer TTL or different deduplication strategy

### 4. Counter Flush SCAN Operations
- **Current**: ~1-100 commands/day (depends on key count)
- **Reason**: SCAN iterates through all counter keys
- **Mitigation**: Already optimized with COUNT parameter (100 per iteration)
- **Further Optimization**: Consider pagination or key indexing

---

## Recommendations for Monitoring

### 1. Track Command Types
Monitor which Redis commands are most frequent:
- BullMQ operations (BRPOP, LPUSH, SET, GET)
- Counter operations (EVAL, MGET, DEL)
- Deduplication (SET NX EX)

### 2. Monitor Key Growth
Track number of keys in Redis:
- `feed:counters:*` keys (should auto-expire after 7 days)
- `metrics:view:*` keys (should auto-expire daily)
- `bull:*` keys (managed by BullMQ)

### 3. Profile SCAN Operations
Measure time for `flushCountersToDaily()` SCAN:
- If > 1 second, consider reducing COUNT or optimizing pattern

### 4. Review Worker Concurrency
Higher concurrency = more polling:
- Monitor actual job processing rate
- Adjust concurrency if jobs are processed faster than polling rate

---

## Summary

**Primary Redis Command Sources** (in order of volume):

1. **BullMQ Worker Polling**: ~35,000-50,000 commands/day (production)
   - Continuous background polling for jobs
   - Optimized with environment-aware settings

2. **Counter Increments**: ~1,000-10,000 commands/day (variable)
   - User actions (views, favorites, bookings, impressions)
   - Optimized with Lua scripts

3. **View Deduplication**: ~500-5,000 commands/day (variable)
   - Unique page views per user/session/IP
   - Optimized with atomic SET NX EX

4. **Notification Enqueuing**: ~200-2,000 commands/day (variable)
   - Email notifications triggered by hooks
   - Standard BullMQ operations

5. **Counter Flush**: ~3-103 commands/day
   - Daily flush of counters to Postgres
   - Optimized with MGET batching

**Total Estimated Daily Volume**:
- Production: ~37,000-67,000 commands/day
- Staging: ~20,800-38,100 commands/day
- Development: ~10,100-15,900 commands/day

**Free Tier Limit**: 10,000 commands/day

**Status**: Production and staging exceed free tier limit. Development is near or slightly over limit.

